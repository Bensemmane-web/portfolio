{% extends 'base.html' %}
{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3 Tree Example</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
      text-anchor: middle;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
    
    .interface-label {
            font-size: 8px; /* Taille de police */
            fill: black;
            text-anchor: middle;
        }
    /* Style pour le texte d'interface en gras */
    .interface-label.bold {
            font-weight: bold;
        }

    .update-link {
            position: absolute;
            top: 0;
            right: 0;
            margin-top: 20px; /* Adjust this value to your preference */
           /* margin-right: 5px;  Adjust this value to your preference */
            display: flex;
            align-items: center;
            text-decoration: none;
            color:#ddd; /* Adjust this color to your preference */
        }

    .update-link:hover{color: steelblue;}
 

  </style>
</head>
<body>
    <a href="{% url 'update_topology' %}" class="update-link">
        <i class="fa fa-solid fa-rotate-right"></i>
    </a> 
  <svg width="960" height="600"></svg>

  <script> 
  
 
var width = window.innerWidth;
var height = window.innerHeight;

var svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height);
    

function calculateStartPoint(d, nodeRadius) {
    var dx = d.target.x - d.source.x;
    var dy = d.target.y - d.source.y;
    var angle = Math.atan2(dy, dx);
    var x = d.source.x + Math.cos(angle) * (nodeRadius + 2);
    var y = d.source.y + Math.sin(angle) * (nodeRadius + 2);
    return [x, y];
}

function calculateEndPoint(d, nodeRadius) {
    var dx = d.target.x - d.source.x;
    var dy = d.target.y - d.source.y;
    var angle = Math.atan2(dy, dx);
    var x = d.target.x - Math.cos(angle) * (nodeRadius + 2);
    var y = d.target.y - Math.sin(angle) * (nodeRadius + 2);
    return [x, y];
}

function calculateInterfacePoint(d) {
    var x = d.source.x + (d.target.x - d.source.x) * 0.3;
    var y = d.source.y + (d.target.y - d.source.y) * 0.3;
    return [x, y];
}

function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
}

function dragstarted(event, d, simulation) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragended(event, d, simulation) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}
function afficherGrapheLSP(lspName) {
    fetch("{% url 'd3_data' %}")
        .then(response => response.json())
        .then(data => {
            console.log("Données reçues :", data);
            var routerData = data.router_data;
            var neighborData = data.neighbor_data;
            var lspData = data.lsp_data;
            console.log("router", routerData);
            console.log("neighbors", neighborData);
            var links = [];
            neighborData.forEach(function(neighbor) {
                var source = routerData.find(node => node.id === neighbor.device_id);
                var target = routerData.find(node => node.hostname === neighbor.neighbor);
                if (source && target) {
                    var link = {source: source,target: target,type: "link"};
                    links.push(link);
                } else {
                    console.error("Node not found for neighbor:", neighbor);
                }
            });

            var lspInfos = lspData.filter(item => item.lsp_name === lspName);
            var primaryFound = false;
            var secondaryFound = false;
            for (var i = 0; i < lspInfos.length; i++) {
            routerSrcInfo = routerData.find(router => router.id === lspInfos[i].lsp_src_id);
            routerDstInfo = routerData.find(router => router.hostname === lspInfos[i].lsp_dst);
        if (lspInfos[i].state.toLowerCase() === "up") {
        if (lspInfos[i].title.toLowerCase() === "primary") {
            console.log("primary");
            primaryFound = true;
            var eroHosteList = lspInfos[i].ero_host.split(',');
            var nouvelElement = routerSrcInfo.hostname ; 
            eroHosteList.unshift(nouvelElement);          
            for (var i = 0; i < eroHosteList.length - 1; i++) {           
                var source = eroHosteList[i];
                routerSrc = routerData.find(router => router.hostname === source);                 
                var target = eroHosteList[i + 1];
                routerDst = routerData.find(router => router.hostname === target);
                var link = {source: routerSrc,target: routerDst ,type:"primaryUP" };
                links.push(link); }
        } else if (lspInfos[i].title.toLowerCase() === "secondary" && !primaryFound) {
            console.log("secondary");
            secondaryFound = true;
            var eroHosteList = lspInfos[i].ero_host.split(',');
            var nouvelElement = routerSrcInfo.hostname ; 
            eroHosteList.unshift(nouvelElement);
            for (var i = 0; i < eroHosteList.length - 1; i++) {
                var source = eroHosteList[i];
                routerSrc = routerData.find(router => router.hostname === source);                  
                var target = eroHosteList[i + 1];
                routerDst = routerData.find(router => router.hostname === target);
                var link = {source: routerSrc, target: routerDst, type:"SecondaryUP"};
                links.push(link);                }
                 }
    }
 }
if (!primaryFound && !secondaryFound) {
      if (routerSrcInfo && routerDstInfo) {
            var link = { 
                source: routerSrcInfo, 
                target: routerDstInfo,
                type:"down",
            };
            links.push(link);
          }}
            var svg = d3.select("svg");
            var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("g")
                .attr("class", "link");
            link.append("line")
                .attr("stroke", function(d) {
                    return d.type === "primaryUP" ? "#66FF00" : d.type === "SecondaryUP" ? "#FF5F1F" : d.type === "down" ? "red" : "white";
                })
                .style("stroke-dasharray", function(d) {
                    return d.type === "down" ? "5, 5" : null;
                });

            link.append("circle")
                .attr("r", 3)
                .attr("class", "start-point")
                .attr("fill", "green");

            link.append("circle")
                .attr("r", 3)
                .attr("class", "end-point")
                .attr("fill", "green");

            link.append("text")
                .attr("class", "interface-label bold")
                .attr("dx", 5)
                .attr("dy", -8)
                .text(function(d) { return d.interface; })
                
            var node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("node")
                .data(routerData)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", function(event, d) { dragstarted(event, d, simulation); })
                    .on("drag", dragged)
                    .on("end", function(event, d) { dragended(event, d, simulation); }))
                    .on("click", function(event, d) {
                        console.log("position ", d.x, d.y);
                        var url = "{% url 'tree_page' %}?hostname=" + encodeURIComponent(d.hostname);
                        window.location.href = url;
                        
                    });

            var nodeRadius = 15;
            var nodes = node.append("circle")
                .attr("r", nodeRadius)
                .attr("id", function(d) { return "router-" + d.hostname; });

            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .style("cursor", "default")
                .text(function(d) { return d.hostname; });

            var simulation = d3.forceSimulation()
                .force("charge", d3.forceManyBody().strength(-100))
                .force("link", d3.forceLink(links).id((d) => d.id).distance(100))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide().radius(140));


            simulation
                .nodes(routerData)
                .on("tick", function() {
                    ticked();
                });

            function ticked() {
                link.selectAll(".start-point")
                    .attr("cx", function(d) { return calculateStartPoint(d, nodeRadius)[0]; })
                    .attr("cy", function(d) { return calculateStartPoint(d, nodeRadius)[1]; });

                link.selectAll(".end-point")
                    .attr("cx", function(d) { return calculateEndPoint(d, nodeRadius)[0]; })
                    .attr("cy", function(d) { return calculateEndPoint(d, nodeRadius)[1]; });

                link.selectAll("line")
                    .attr("x1", function(d) { return calculateStartPoint(d, nodeRadius)[0]; })
                    .attr("y1", function(d) { return calculateStartPoint(d, nodeRadius)[1]; })
                    .attr("x2", function(d) { return calculateEndPoint(d, nodeRadius)[0]; })
                    .attr("y2", function(d) { return calculateEndPoint(d, nodeRadius)[1]; });

                link.selectAll(".interface-label")
                    .attr("x", function(d) { return calculateInterfacePoint(d)[0]; })
                    .attr("y", function(d) { return calculateInterfacePoint(d)[1]; });

                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            }
        })
        .catch(error => {
            console.error('Erreur lors de la récupération des données:', error);
        });
}
 
 function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

    var lsp_name = getParameterByName('lsp_name');
    if (lsp_name) {
        afficherGrapheLSP(lsp_name);
    } else {
        console.error("Le paramètre 'lsp_name' n'est pas défini dans l'URL.");
    }

  </script>
</body>
</html>
{% endblock %}