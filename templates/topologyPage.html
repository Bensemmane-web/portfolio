{% extends 'base.html' %}
{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3 Tree Example</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="treePage.html"></script>
  <style>
    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }
    .node text {
      font: 12px sans-serif;
      text-anchor: middle;
    }
    .link {
      fill: none;
      stroke: #ccc;
    }
  
    .interface-label {
            font-size: 8px; /* Taille de police */
            stroke: white;
            text-anchor: middle;
             /* Valeur inférieure pour une écriture plus fine */
    
        }
   

    .update-link {
            position: absolute;
            top: 0;
            right: 0;
            margin-top: 20px; /* Adjust this value to your preference */
           /* margin-right: 5px;  Adjust this value to your preference */
            display: flex;
            align-items: center;
            text-decoration: none;
            color:#ddd; /* Adjust this color to your preference */
        }

    .update-link:hover{color: steelblue;}
    .custom-button:active {
        cursor: pointer; /* Définir le curseur sur pointer */
    }

  </style>
</head>
<body>

  <a href="{% url 'update_topology' %}" class="update-link">
        <i class="fa fa-solid fa-rotate-right"></i>
    </a> 
  <svg width="960" height="600"></svg>

  <script> 
var width = window.innerWidth;
var height = window.innerHeight;

var svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height);
    
function calculateStartPoint(d, nodeRadius) {
    var dx = d.target.x - d.source.x;
    var dy = d.target.y - d.source.y;
    var angle = Math.atan2(dy, dx);
    var x = d.source.x + Math.cos(angle) * (nodeRadius + 2);
    var y = d.source.y + Math.sin(angle) * (nodeRadius + 2);
    return [x, y];
}

function calculateEndPoint(d, nodeRadius) {
    var dx = d.target.x - d.source.x;
    var dy = d.target.y - d.source.y;
    var angle = Math.atan2(dy, dx);
    var x = d.target.x - Math.cos(angle) * (nodeRadius + 2);
    var y = d.target.y - Math.sin(angle) * (nodeRadius + 2);
    return [x, y];
}

function calculateInterfacePoint(d) {
    var x = d.source.x + (d.target.x - d.source.x) * 0.3;
    var y = d.source.y + (d.target.y - d.source.y) * 0.3;
    return [x, y];
}

function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
}

function dragstarted(event, d, simulation) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragended(event, d, simulation) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

function afficherGrapheD3() {
    fetch("{% url 'd3_data' %}")
        .then(response => response.json())
        .then(data => {
            console.log("Données reçues :", data);
            var routerData = data.router_data;
            console.log(routerData);
            var neighborData = data.neighbor_data;
            console.log(neighborData);
            var lspData = data.lsp_data;
            console.log(lspData.lsp_name);
            var links = [];
            neighborData.forEach(function(neighbor) {
                var source = routerData.find(node => node.id === neighbor.device_id);
                var target = routerData.find(node => node.hostname === neighbor.neighbor);
                if (source && target) {
                    var link = { 
                        source: source, 
                        target: target,
                        interface: neighbor.interface 
                    };
                    links.push(link);
                } else {
                    console.error("Node not found for neighbor:", neighbor);
                }
            });

            var svg = d3.select("svg");
            var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("g")
                .attr("class", "link");

            link.append("line")
                .attr("stroke", "white");

            link.append("circle")
                .attr("r", 3)
                .attr("class", "start-point")
                .attr("fill", "green");

            link.append("circle")
                .attr("r", 3)
                .attr("class", "end-point")
                .attr("fill", "green");

            link.append("text")
                .attr("class", "interface-label ")
                .attr("dx", 5)
                .attr("dy", -8)
                .style("cursor", "default")
                .text(function(d) { return d.interface; })
                
            var node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("node")
                .data(routerData)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", function(event, d) { dragstarted(event, d, simulation); })
                    .on("drag", dragged)
                    .on("end", function(event, d) { dragended(event, d, simulation); }))
                    .on("click", function(event, d) {
                    d3.select(this).style("cursor", "pointer");    
        var url = "{% url 'tree_page' %}?hostname=" + encodeURIComponent(d.hostname);
        window.location.href = url;
    });

            var nodeRadius = 15;
            var nodes = node.append("circle")
                .attr("r", nodeRadius);

            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .style("cursor", "default")
                .text(function(d) { return d.hostname; });

            var simulation = d3.forceSimulation()
                .force("charge", d3.forceManyBody().strength(-100))
                .force("link", d3.forceLink(links).id((d) => d.id).distance(100))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide().radius(140));

            simulation
                .nodes(routerData)
                .on("tick", function() {
                    ticked();
                });

            function ticked() {
                link.selectAll(".start-point")
                    .attr("cx", function(d) { return calculateStartPoint(d, nodeRadius)[0]; })
                    .attr("cy", function(d) { return calculateStartPoint(d, nodeRadius)[1]; });
                link.selectAll(".end-point")
                    .attr("cx", function(d) { return calculateEndPoint(d, nodeRadius)[0]; })
                    .attr("cy", function(d) { return calculateEndPoint(d, nodeRadius)[1]; });
                link.selectAll("line")
                    .attr("x1", function(d) { return calculateStartPoint(d, nodeRadius)[0]; })
                    .attr("y1", function(d) { return calculateStartPoint(d, nodeRadius)[1]; })
                    .attr("x2", function(d) { return calculateEndPoint(d, nodeRadius)[0]; })
                    .attr("y2", function(d) { return calculateEndPoint(d, nodeRadius)[1]; });
                link.selectAll(".interface-label")
                    .attr("x", function(d) { return calculateInterfacePoint(d)[0]; })
                    .attr("y", function(d) { return calculateInterfacePoint(d)[1]; });
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            }
        })
        .catch(error => {
            console.error('Erreur lors de la récupération des données:', error);
        });
}

afficherGrapheD3();

  </script>
</body>
</html>
{% endblock %}